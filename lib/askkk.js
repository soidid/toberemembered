// Generated by LiveScript 1.2.0
var ref$, keys, values, pairsToObj, AskKK;
ref$ = require('prelude-ls'), keys = ref$.keys, values = ref$.values, pairsToObj = ref$.pairsToObj;
AskKK = (function(){
  AskKK.displayName = 'AskKK';
  var prototype = AskKK.prototype, constructor = AskKK;
  function AskKK(arg$){
    var firebaseUrl, ref$, firebase;
    firebaseUrl = (ref$ = arg$.firebaseUrl) != null ? ref$ : null, firebase = (ref$ = arg$.firebase) != null ? ref$ : null;
    if (firebase) {
      this._firebase = firebase;
    } else if (firebaseUrl) {
      this._firebase = new Firebase(firebaseUrl);
    } else {
      throw new Error("No Firebase provided.");
    }
    this._userId = 1;
    this._candidateId = 1;
    this._petitionThreshold = 1000;
  }
  /**
   * Set candidate info.  If there is a candidate of the
   * same ID, her/his info will be erased.
   */
  prototype.setCandidate = function(id, arg$, onComplete){
    var name, email, candidateRef;
    name = arg$.name, email = arg$.email;
    candidateRef = this._firebase.child('/candidates').child(id);
    return candidateRef.set({
      id: id,
      name: name,
      email: email
    }, onComplete);
  };
  /**
   * Get candidate info from id.
   * Candidates ID are maintained by administrators.
   */
  prototype.getCandidate = function(id, onComplete){
    var candidateRef;
    id == null && (id = null);
    candidateRef = id
      ? this._firebase.child('/candidates').child(id)
      : this._firebase.child('/candidates');
    return candidateRef.on('value', function(snapshot){
      return onComplete(id
        ? snapshot.val()
        : values(snapshot.val()));
    });
  };
  /**
   * Update candidate info.  If there is a candidate of the
   * same ID, only the info specified in data will be updated.
   */
  prototype.updateCandidate = function(id, data, onComplete){
    var d, i$, ref$, len$, k, candidateRef;
    d = {
      id: id
    };
    for (i$ = 0, len$ = (ref$ = ['name', 'email']).length; i$ < len$; ++i$) {
      k = ref$[i$];
      if (data[k]) {
        d[k] = data[k];
      }
    }
    candidateRef = this._firebase.child('/candidates').child(id);
    return candidateRef.update(d, onComplete);
  };
  /**
   * Create a user.  User IDs are created by the `push`
   * method of Firebase.  onComplete is a callback whose
   * argument is an object containing user info, including ID.
   */
  prototype.createUser = function(arg$, onComplete){
    var name, email, usersRef, newRef;
    name = arg$.name, email = arg$.email;
    usersRef = this._firebase.child('/users');
    newRef = usersRef.push();
    return newRef.set({
      id: newRef.name(),
      name: name,
      email: email
    }, function(error){
      if (error) {
        return onComplete(error);
      } else {
        return newRef.on('value', function(snapshot){
          return onComplete(snapshot.val());
        });
      }
    });
  };
  /**
   * Get user info by ID.
   */
  prototype.getUser = function(id, onComplete){
    var userRef;
    userRef = this._firebase.child('/users').child(id);
    return userRef.on('value', function(snapshot){
      return onComplete(snapshot.val());
    });
  };
  /**
   * Update user info.
   * Only the info specified in the data will be updated.
   * If there are no user of the given ID, nothing happens,
   * and onComplete will be called with a null.
   */
  prototype.updateUser = function(id, data, onComplete){
    var d, i$, ref$, len$, k, userRef;
    d = {
      id: id
    };
    for (i$ = 0, len$ = (ref$ = ['name', 'email']).length; i$ < len$; ++i$) {
      k = ref$[i$];
      if (data[k]) {
        d[k] = data[k];
      }
    }
    userRef = this._firebase.child('/users').child(id);
    return userRef.on('value', function(snapshot){
      if (snapshot.val()) {
        return userRef.update(d, function(snapshot){
          return userRef.on('value', function(snapshot){
            return onComplete(snapshot.val());
          });
        });
      } else {
        return onComplete();
      }
    });
  };
  /**
   * Create a petition.
   */
  prototype.createPetition = function(arg$, onComplete){
    var title, candidates, story, petitionRef, userPetitionRef, candidateMetaRef, petitionIndexRef, data;
    title = arg$.title, candidates = arg$.candidates, story = arg$.story;
    if (!this._userId) {
      throw new Error("Need to be a user to create a petition.");
    }
    petitionRef = this._firebase.child('petitions').push();
    userPetitionRef = this._firebase.child('user_meta').child(this._userId).child('petitions');
    candidateMetaRef = this._firebase.child('candidate_meta');
    petitionIndexRef = this._firebase.child('petition_index');
    data = {
      id: petitionRef.name(),
      author: this._userId,
      candidates: pairsToObj(
      candidates.map(function(it){
        return [it, true];
      })),
      title: title,
      story: story
    };
    return petitionRef.set(data, function(error){
      var i$, ref$, len$, ca;
      if (error) {
        throw new Error("Error created a petition: " + error);
      }
      userPetitionRef.child(petitionRef.name()).set(true);
      for (i$ = 0, len$ = (ref$ = candidates).length; i$ < len$; ++i$) {
        ca = ref$[i$];
        candidateMetaRef.child(ca).child('petitions').child(petitionRef.name()).set(true);
      }
      petitionIndexRef.child('open').child(petitionRef.name()).set(true);
      return onComplete(data);
    });
  };
  /**
   * Get petition info
   */
  prototype.getPetition = function(id, onComplete){
    return this._firebase.child('petitions').child(id).on('value', function(snapshot){
      return onComplete(snapshot.val());
    });
  };
  /**
   * Sign an open petition to agree that it should be answered.
   * Example: sign('-JFsstiW6QzJkRG3kh09', function (error) {})
   */
  prototype.sign = function(id, onComplete){
    var petitionRef, petitionMetaRef, signatureRef, passedRef;
    if (!this._userId) {
      throw new Error("Need to be a user to sign a petition.");
    }
    petitionRef = this._firebase.child('petitions').child(id);
    petitionMetaRef = this._firebase.child('petition_meta').child(id);
    signatureRef = petitionMetaRef.child('signatures').child(this._userId);
    passedRef = this._firebase.child('petition_index/passed').child(id);
    return signatureRef.once('value', function(snapshot){
      if (snapshot.val()) {
        return onComplete(null);
      }
      return signatureRef.set(true, function(error){
        if (error) {
          onComplete(error);
        }
        return petitionRef.child('signatures').transaction(function(currentValue){
          return currentValue + 1;
        }, function(error, committed, snapshot){
          if (error) {
            return onComplete(error);
          }
          if (snapshot.val() < this._petitionThreshold) {
            return onComplete(null);
          }
          return passedRef.set(true, function(error){
            if (error) {
              return onComplete(error);
            }
            return petitionRef.child('status/passed').set(true, function(error){
              return onComplete(error);
            });
          });
        });
      });
    });
  };
  /**
   * Respond to a petition.
   */
  prototype.respond = function(arg$, onComplete){
    var content, petitions, responseRef, petitionsRef, data;
    content = arg$.content, petitions = arg$.petitions;
    responseRef = this._firebase.child('responses').push();
    petitionsRef = this._firebase.child('petitions');
    data = {
      id: responseRef.name(),
      cantitate: this._candidateId,
      petitions: pairsToObj(
      petitions.map(function(it){
        return [it, true];
      })),
      content: content
    };
    return responseRef.set(data, function(error){
      var i$, ref$, len$, p;
      if (error) {
        onComplete(error);
      }
      for (i$ = 0, len$ = (ref$ = petitions).length; i$ < len$; ++i$) {
        p = ref$[i$];
        petitionsRef.child(p).child('responses').child(responseRef.name()).set(true);
      }
      return onComplete(null, data);
    });
  };
  /**
   * Vote an answer as good/not good.
   */
  prototype.vote = function(responseId, updown, onComplete){
    var responseRef, responseMetaRef, userMetaRef;
    updown == null && (updown = null);
    responseRef = this._firebase.child("responses/" + responseId + "/votes").child(updown === 'up' ? 'up' : 'down');
    responseMetaRef = this._firebase.child("response_meta/" + responseId + "/votes/" + updown + "/" + this._userId);
    userMetaRef = this._firebase.child("user_meta/" + this._userId + "/votes/" + responseId);
    return responseRef.transaction(function(currentValue){
      return currentValue + 1;
    }, function(error, committed, snapshot){
      if (error) {
        return onComplete(error);
      }
      return responseMetaRef.set(true, function(error){
        return userMetaRef.set(updown, function(error){
          return onComplete(error);
        });
      });
    });
  };
  return AskKK;
}());